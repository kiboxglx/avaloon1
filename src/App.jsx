import React, { useState, useEffect, useCallback } from 'react';
import { Search, Monitor, RefreshCw, Plus, LogOut } from 'lucide-react';
import ClientCard from './components/ClientCard';
import ProfileModal from './components/ProfileModal';
import TvModeTable from './components/TvModeTable';
import { fetchInstagramData } from './services/apify';
import StatsOverview from './components/StatsOverview';
import EmptyState from './components/EmptyState';
import AvaloonLogo from './components/AvaloonLogo';
import { initialClients } from './data/clients';
import { supabase } from './services/supabase';

function App() {
  const [clients, setClients] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterType, setFilterType] = useState('all'); // all, alert, onTrack
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isTvMode, setIsTvMode] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [editingClient, setEditingClient] = useState(null);

  // Fetch clients from Supabase on load
  useEffect(() => {
    fetchClients();
  }, []);

  const fetchClients = async () => {
    setIsLoading(true);
    try {
      const { data, error } = await supabase
        .from('clients')
        .select('*')
        .order('name');

      if (error) throw error;

      if (data && data.length > 0) {
        // Map Supabase columns to app state (snake_case to camelCase if needed, but we kept it simple)
        const formattedData = data.map(client => ({
          ...client,
          latestPostDate: client.latest_post_date // Map database column to app property
        }));
        setClients(formattedData);
      } else {
        // If DB is empty, seed with initial data
        await seedInitialData();
      }
    } catch (error) {
      console.error('Error fetching clients:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const seedInitialData = async () => {
    console.log('Seeding initial data to Supabase...');
    const clientsToInsert = initialClients.map(c => ({
      name: c.name,
      username: c.username,
      manager: c.manager,
      days: c.days,
      followers: c.followers,
      following: c.following,
      posts: c.posts,
      engagement: c.engagement,
      latest_post_date: c.latestPostDate
    }));

    const { data, error } = await supabase.from('clients').insert(clientsToInsert).select();

    if (error) {
      console.error('Error seeding data:', error);
    } else {
      // Re-fetch to get the IDs generated by Supabase
      fetchClients();
    }
  };

  const handleAddClient = async (newClient) => {
    try {
      const clientToSave = {
        name: newClient.name,
        username: newClient.username,
        manager: newClient.manager,
        days: 0,
        followers: '0',
        following: '0',
        posts: '0',
        engagement: '0%',
        latest_post_date: new Date().toISOString()
      };

      const { data, error } = await supabase.from('clients').insert([clientToSave]).select();

      if (error) throw error;

      if (data) {
        const addedClient = { ...data[0], latestPostDate: data[0].latest_post_date };
        setClients(prev => [...prev, addedClient]);
        setIsModalOpen(false);
        // Optionally refresh data immediately
        handleRefresh([addedClient]);
      }
    } catch (error) {
      console.error('Error adding client:', error);
      alert('Erro ao adicionar cliente. Tente novamente.');
    }
  };

  const handleEditClient = (client) => {
    setEditingClient(client);
    setIsModalOpen(true);
  };

  const handleSaveProfile = async (formData) => {
    if (editingClient) {
      // Update existing
      try {
        const { error } = await supabase
          .from('clients')
          .update({
            name: formData.name,
            username: formData.username,
            manager: formData.manager
          })
          .eq('id', editingClient.id);

        if (error) throw error;

        setClients(clients.map(c =>
          c.id === editingClient.id ? { ...c, ...formData } : c
        ));
        setIsModalOpen(false);
        setEditingClient(null);
      } catch (error) {
        console.error('Error updating client:', error);
        alert('Erro ao atualizar cliente.');
      }
    } else {
      // Add new
      handleAddClient(formData);
    }
  };

  const handleDeleteClient = async (id) => {
    if (window.confirm('Tem certeza que deseja excluir este cliente?')) {
      try {
        const { error } = await supabase.from('clients').delete().eq('id', id);
        if (error) throw error;
        setClients(clients.filter(c => c.id !== id));
      } catch (error) {
        console.error('Error deleting client:', error);
        alert('Erro ao excluir cliente.');
      }
    }
  };

  const handleRefresh = useCallback(async (clientsToUpdate = clients) => {
    setIsRefreshing(true);
    const usernames = clientsToUpdate.map(c => c.username.replace('@', '')); // Remove @ for API if needed

    try {
      const updates = await fetchInstagramData(usernames);

      // Update local state and Supabase
      const updatedClients = clients.map(client => {
        const usernameKey = client.username.replace('@', '');
        const update = updates[usernameKey] || updates[client.username]; // Check both formats
        if (update) {
          return { ...client, ...update };
        }
        return client;
      });

      setClients(updatedClients);

      // Batch update to Supabase (doing one by one for simplicity in this MVP)
      for (const client of updatedClients) {
        const usernameKey = client.username.replace('@', '');
        const update = updates[usernameKey] || updates[client.username]; // Check both formats
        if (update) {
          await supabase.from('clients').update({
            days: update.days,
            followers: update.followers,
            following: update.following,
            posts: update.posts,
            engagement: update.engagement,
            latest_post_date: update.latestPostDate
          }).eq('id', client.id);
        }
      }

    } catch (error) {
      console.error("Failed to refresh data:", error);
      alert("Falha ao atualizar dados do Instagram. Verifique o console.");
    } finally {
      setIsRefreshing(false);
    }
  }, [clients]); // Dependency on clients to ensure it uses the latest list

  // Atualização automática a cada 6 horas
  useEffect(() => {
    const SIX_HOURS = 6 * 60 * 60 * 1000;
    const interval = setInterval(() => {
      console.log('Executando atualização automática (6h)...');
      handleRefresh();
    }, SIX_HOURS);
    return () => clearInterval(interval);
  }, [handleRefresh]);

  const filteredClients = clients.filter(client => {
    const matchesSearch = client.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      client.username.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = filterType === 'all' ? true : client.days >= 3;

    return matchesSearch && matchesFilter;
  }).sort((a, b) => {
    // Prioridade: Vermelho (> 2) > Laranja (>= 1) > Verde (0)
    const getPriority = (days) => {
      if (days >= 3) return 3;
      if (days === 2) return 2;
      return 1;
    };

    const priorityA = getPriority(a.days);
    const priorityB = getPriority(b.days);

    if (priorityA !== priorityB) {
      return priorityB - priorityA; // Maior prioridade primeiro
    }

    return b.days - a.days; // Mais dias de atraso primeiro
  });

  return (
    <div className="min-h-screen p-4 md:p-8 font-sans selection:bg-primary/30 selection:text-primary-foreground">
      {/* Header */}
      <header className="flex flex-col md:flex-row justify-between items-center mb-10 gap-6">
        <div className="transform hover:scale-105 transition-transform duration-300">
          <AvaloonLogo className="h-20 md:h-24" />
        </div>

        <div className="flex flex-wrap justify-center gap-3 md:gap-4 w-full md:w-auto">
          <button
            onClick={() => setIsTvMode(!isTvMode)}
            className={`flex items-center gap-2 px-5 py-2.5 rounded-xl transition-all duration-300 font-medium border ${isTvMode ? 'bg-secondary border-secondary text-white shadow-[0_0_20px_rgba(255,87,34,0.4)]' : 'glass-button text-zinc-300 border-white/10 hover:border-secondary/50'} `}
          >
            <Monitor size={18} /> <span className="hidden sm:inline">Modo TV</span>
          </button>

          <button
            onClick={() => handleRefresh(clients)}
            disabled={isRefreshing}
            className={`flex items-center gap-2 px-5 py-2.5 rounded-xl transition-all duration-300 font-medium border glass-button text-zinc-300 border-white/10 hover:border-secondary/50 hover:text-white ${isRefreshing ? 'opacity-50 cursor-not-allowed' : ''} `}
          >
            <RefreshCw size={18} className={isRefreshing ? 'animate-spin' : ''} />
            <span className="hidden sm:inline">{isRefreshing ? 'Atualizando...' : 'Atualizar'}</span>
          </button>

          <button
            onClick={() => {
              setEditingClient(null);
              setIsModalOpen(true);
            }}
            className="flex items-center gap-2 px-5 py-2.5 bg-secondary rounded-xl hover:shadow-[0_0_25px_rgba(255,87,34,0.5)] hover:scale-105 transition-all duration-300 font-bold text-white border border-white/10"
          >
            <Plus size={20} strokeWidth={3} /> <span className="hidden sm:inline">Adicionar</span>
          </button>

          <button className="flex items-center gap-2 px-5 py-2.5 rounded-xl transition-all duration-300 font-medium border glass-button text-zinc-400 hover:text-red-400 hover:border-red-500/30">
            <LogOut size={18} />
          </button>
        </div>
      </header>

      {/* Stats Overview */}
      {!isTvMode && <StatsOverview clients={clients} />}

      {/* Filters */}
      <div className="glass-panel rounded-2xl p-2 mb-10 flex flex-col md:flex-row justify-between items-center gap-4">
        <div className="relative w-full md:w-96 group">
          <Search className="absolute left-4 top-1/2 transform -translate-y-1/2 text-zinc-500 group-focus-within:text-secondary transition-colors" size={20} />
          <input
            type="text"
            placeholder="Buscar perfis..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-full bg-transparent text-white pl-12 pr-4 py-3 rounded-xl focus:outline-none placeholder-zinc-600 input-glow transition-all"
          />
        </div>

        <div className="flex gap-2 w-full md:w-auto p-1 bg-black/20 rounded-xl">
          <button
            onClick={() => setFilterType('alert')}
            className={`flex-1 md:flex-none px-6 py-2.5 rounded-lg transition-all duration-300 font-medium text-sm ${filterType === 'alert' ? 'bg-secondary text-white shadow-lg' : 'text-zinc-400 hover:text-white hover:bg-white/5'} `}
          >
            Em Alerta
          </button>
          <button
            onClick={() => setFilterType('all')}
            className={`flex-1 md:flex-none px-6 py-2.5 rounded-lg transition-all duration-300 font-medium text-sm ${filterType === 'all' ? 'bg-zinc-700 text-white shadow-lg' : 'text-zinc-400 hover:text-white hover:bg-white/5'} `}
          >
            Todos
          </button>
        </div>
      </div>

      {/* Grid or TV Mode */}
      {isTvMode ? (
        <TvModeTable clients={filteredClients} onExit={() => setIsTvMode(false)} />
      ) : (
        <>
          {filteredClients.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
              {filteredClients.map(client => (
                <ClientCard
                  key={client.id}
                  client={client}
                  onEdit={() => handleEditClient(client)}
                  onDelete={() => handleDeleteClient(client.id)}
                />
              ))}
            </div>
          ) : (
            <EmptyState
              message={searchTerm ? `Nenhum resultado para "${searchTerm}"` : "Nenhum cliente encontrado"}
              subMessage={filterType === 'alert' ? "Nenhum cliente está em alerta no momento." : "Adicione um novo perfil para começar."}
            />
          )}
        </>
      )}

      <ProfileModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        onSave={handleSaveProfile}
        initialData={editingClient}
      />
    </div>
  );
}

export default App;
